/*
			!!!Warning!!!
			This is autogenerated code! 
*/
		
const assert        = require('node:assert');
const AbstractCoder = require('../AbstractCoder.js');


//basic.js
	const maxUIntByBytes = [null, 255, 65535, 16777215, 4294967295, 1099511627775, 281474976710655]
	const maxIntByBytes  = [null, 127, 32767, 8388607, 2147483647, 549755813887, 140737488355327]
	const minIntByBytes  = [null, -129, -32769, -8388609, -2147483649, -549755813889, -140737488355329]

//uIntX.js
	const MaxUIntXB0 = 240;
	const MaxUIntXB1 = MaxUIntXB0 + 256*9;
	const MaxUIntXB2 = MaxUIntXB1 + Math.pow(2, 2*8);
	const MaxUIntXB3 = MaxUIntXB2 + Math.pow(2, 3*8);
	const MaxUIntXB4 = MaxUIntXB3 + Math.pow(2, 4*8);
	const MaxUIntXB5 = MaxUIntXB4 + Math.pow(2, 5*8);
	const MaxUIntXB6 = 0          + Math.pow(2, 6*8); //чтобы не было переполнения
	const MaxUIntXBM = [0, MaxUIntXB0, MaxUIntXB1, MaxUIntXB2, MaxUIntXB3, MaxUIntXB4, MaxUIntXB5, MaxUIntXB6];

//uDoubleH.js
	const ud_hexToChar = [
		'0',   //0
		'1',   //1
		'2',   //2
		'3',   //3
		'4',   //4
		'5',   //5
		'6',   //6
		'7',   //7
		'8',   //8
		'9',   //9
		'.',   //10
		'e-',  //11
		'e+',  //12
		'00',  //13
		'.0',  //14
		'000', //15
	]
	const ud_cArr = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; //speedUp
	const ud_map = new Map([ //['0', 0], //speedUp
		['1', 1], ['2', 2], ['3', 3],
		['4', 4], ['5', 5], ['6', 6], 
		['7', 7], ['8', 8], ['9', 9]
	]); 
	ud_get = ud_map.get.bind(ud_map); //speedUp

class SafeCoder extends AbstractCoder {
	
		//basic.js
	
			//Int8
				readNextInt8(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 1 > this.buf.length) throw new Error('Int8:this.pos + 1 = '+(this.pos+1)+'> this.buf.length='+this.buf.length);
					return this._typedInt8[this.pos++];
				}
				writeNextInt8(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 1 > this.buf.length) throw new Error('Int8:this.pos + 1 = '+(this.pos+1)+'> this.buf.length='+this.buf.length); 
					if(!Number.isInteger(val)) throw new Error('Int8: val='+val+' typeof='+typeof(val));
					if(val<-128 || val>127) throw new Error('Int8: must be in range [-128, 127]. Given: '+val); 
					this._typedInt8[this.pos++] = val;
				}
				bytesInt8() {return 1;}
	
			//UInt8
				readNextUInt8(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 1 > this.buf.length) throw new Error('UInt8:this.pos + 1 = '+(this.pos+1)+'> this.buf.length='+this.buf.length);
					return this._typedUInt8[this.pos++];
				}
				writeNextUInt8(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 1 > this.buf.length) throw new Error('UInt8:this.pos + 1 = '+(this.pos+1)+'> this.buf.length='+this.buf.length); 
					if(!Number.isInteger(val)) throw new Error('UInt8: val='+val+' typeof='+typeof(val));
					if(val<0 || val>255) throw new Error('UInt8: must be in range [0, 255]. Given: '+val); 
					this._typedUInt8[this.pos++] = val;
				}
				bytesUInt8() {return 1;}
	
			//Int16BE
				readNextInt16BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 2 > this.buf.length) throw new Error('Int16:this.pos + 2 = '+(this.pos+2)+'> this.buf.length='+this.buf.length);
					const res  = this.getInt16(this.pos, false);
					this.pos  += 2;
					return res;
				}
				writeNextInt16BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 2 > this.buf.length) throw new Error('Int16:this.pos + 2 = '+(this.pos+2)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int16: val='+val+' typeof='+typeof(val));
					if(val<-32768 || val>32767) throw new Error('Int16: must be in range [-32768, 32767]. Given: '+val);						
					this.setInt16(this.pos, val, false)
					this.pos  += 2;
				}
				bytesInt16BE(val) {return 2;}
	
			//Int16LE
				readNextInt16LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 2 > this.buf.length) throw new Error('Int16:this.pos + 2 = '+(this.pos+2)+'> this.buf.length='+this.buf.length);
					const res  = this.getInt16(this.pos, true);
					this.pos  += 2;
					return res;
				}
				writeNextInt16LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 2 > this.buf.length) throw new Error('Int16:this.pos + 2 = '+(this.pos+2)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int16: val='+val+' typeof='+typeof(val));
					if(val<-32768 || val>32767) throw new Error('Int16: must be in range [-32768, 32767]. Given: '+val);						
					this.setInt16(this.pos, val, true)
					this.pos  += 2;
				}
				bytesInt16LE(val) {return 2;}
	
			//UInt16BE
				readNextUInt16BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 2 > this.buf.length) throw new Error('UInt16:this.pos + 2 = '+(this.pos+2)+'> this.buf.length='+this.buf.length);
					const res  = this.getUInt16(this.pos, false);
					this.pos  += 2;
					return res;
				}
				writeNextUInt16BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 2 > this.buf.length) throw new Error('UInt16:this.pos + 2 = '+(this.pos+2)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt16: val='+val+' typeof='+typeof(val));
					if(val<0 || val>65535) throw new Error('UInt16: must be in range [0, 65535]. Given: '+val);						
					this.setUInt16(this.pos, val, false)
					this.pos  += 2;
				}
				bytesUInt16BE(val) {return 2;}
	
			//UInt16LE
				readNextUInt16LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 2 > this.buf.length) throw new Error('UInt16:this.pos + 2 = '+(this.pos+2)+'> this.buf.length='+this.buf.length);
					const res  = this.getUInt16(this.pos, true);
					this.pos  += 2;
					return res;
				}
				writeNextUInt16LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 2 > this.buf.length) throw new Error('UInt16:this.pos + 2 = '+(this.pos+2)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt16: val='+val+' typeof='+typeof(val));
					if(val<0 || val>65535) throw new Error('UInt16: must be in range [0, 65535]. Given: '+val);						
					this.setUInt16(this.pos, val, true)
					this.pos  += 2;
				}
				bytesUInt16LE(val) {return 2;}
	
			//Int32BE
				readNextInt32BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('Int32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					const res  = this.getInt32(this.pos, false);
					this.pos  += 4;
					return res;
				}
				writeNextInt32BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('Int32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int32: val='+val+' typeof='+typeof(val));
					if(val<-2147483648 || val>2147483647) throw new Error('Int32: must be in range [-2147483648, 2147483647]. Given: '+val);						
					this.setInt32(this.pos, val, false)
					this.pos  += 4;
				}
				bytesInt32BE(val) {return 4;}
	
			//Int32LE
				readNextInt32LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('Int32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					const res  = this.getInt32(this.pos, true);
					this.pos  += 4;
					return res;
				}
				writeNextInt32LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('Int32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int32: val='+val+' typeof='+typeof(val));
					if(val<-2147483648 || val>2147483647) throw new Error('Int32: must be in range [-2147483648, 2147483647]. Given: '+val);						
					this.setInt32(this.pos, val, true)
					this.pos  += 4;
				}
				bytesInt32LE(val) {return 4;}
	
			//UInt32BE
				readNextUInt32BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('UInt32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					const res  = this.getUInt32(this.pos, false);
					this.pos  += 4;
					return res;
				}
				writeNextUInt32BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('UInt32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt32: val='+val+' typeof='+typeof(val));
					if(val<0 || val>4294967295) throw new Error('UInt32: must be in range [0, 4294967295]. Given: '+val);						
					this.setUInt32(this.pos, val, false)
					this.pos  += 4;
				}
				bytesUInt32BE(val) {return 4;}
	
			//UInt32LE
				readNextUInt32LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('UInt32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					const res  = this.getUInt32(this.pos, true);
					this.pos  += 4;
					return res;
				}
				writeNextUInt32LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('UInt32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt32: val='+val+' typeof='+typeof(val));
					if(val<0 || val>4294967295) throw new Error('UInt32: must be in range [0, 4294967295]. Given: '+val);						
					this.setUInt32(this.pos, val, true)
					this.pos  += 4;
				}
				bytesUInt32LE(val) {return 4;}
	
			//Float32BE
				readNextFloat32BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('Float32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					const res  = this.getFloat32(this.pos, false);
					this.pos  += 4;
					return res;
				}
				writeNextFloat32BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('Float32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					if(typeof(val)!=='number') throw new Error('Float32: val='+val+' typeof='+typeof(val));						
					this.setFloat32(this.pos, val, false)
					this.pos  += 4;
				}
				bytesFloat32BE(val) {return 4;}
	
			//Float32LE
				readNextFloat32LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('Float32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					const res  = this.getFloat32(this.pos, true);
					this.pos  += 4;
					return res;
				}
				writeNextFloat32LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 4 > this.buf.length) throw new Error('Float32:this.pos + 4 = '+(this.pos+4)+'> this.buf.length='+this.buf.length);
					if(typeof(val)!=='number') throw new Error('Float32: val='+val+' typeof='+typeof(val));						
					this.setFloat32(this.pos, val, true)
					this.pos  += 4;
				}
				bytesFloat32LE(val) {return 4;}
	
			//Float64BE
				readNextFloat64BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('Float64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					const res  = this.getFloat64(this.pos, false);
					this.pos  += 8;
					return res;
				}
				writeNextFloat64BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('Float64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					if(typeof(val)!=='number') throw new Error('Float64: val='+val+' typeof='+typeof(val));						
					this.setFloat64(this.pos, val, false)
					this.pos  += 8;
				}
				bytesFloat64BE(val) {return 8;}
	
			//Float64LE
				readNextFloat64LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('Float64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					const res  = this.getFloat64(this.pos, true);
					this.pos  += 8;
					return res;
				}
				writeNextFloat64LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('Float64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					if(typeof(val)!=='number') throw new Error('Float64: val='+val+' typeof='+typeof(val));						
					this.setFloat64(this.pos, val, true)
					this.pos  += 8;
				}
				bytesFloat64LE(val) {return 8;}
	
			//BigInt64BE
				readNextBigInt64BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('BigInt64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					const res  = this.getBigInt64(this.pos, false);
					this.pos  += 8;
					return res;
				}
				writeNextBigInt64BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('BigInt64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					if(typeof(val)!=='bigint'){ if(!Number.isInteger(val)) throw new Error('BigInt64: val='+val+' typeof='+typeof(val));						
						val = BigInt(val)
					}
					if(val<-9223372036854775808n || val>9223372036854775807n) throw new Error('BigInt64: must be in range [-9223372036854775808n, 9223372036854775807n]. Given: '+val);						
					this.setBigInt64(this.pos, val, false)
					this.pos  += 8;
				}
				bytesBigInt64BE(val) {return 8;}
	
			//BigInt64LE
				readNextBigInt64LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('BigInt64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					const res  = this.getBigInt64(this.pos, true);
					this.pos  += 8;
					return res;
				}
				writeNextBigInt64LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('BigInt64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					if(typeof(val)!=='bigint'){ if(!Number.isInteger(val)) throw new Error('BigInt64: val='+val+' typeof='+typeof(val));						
						val = BigInt(val)
					}
					if(val<-9223372036854775808n || val>9223372036854775807n) throw new Error('BigInt64: must be in range [-9223372036854775808n, 9223372036854775807n]. Given: '+val);						
					this.setBigInt64(this.pos, val, true)
					this.pos  += 8;
				}
				bytesBigInt64LE(val) {return 8;}
	
			//BigUInt64BE
				readNextBigUInt64BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('BigUInt64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					const res  = this.getBigUInt64(this.pos, false);
					this.pos  += 8;
					return res;
				}
				writeNextBigUInt64BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('BigUInt64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					if(typeof(val)!=='bigint'){ if(!Number.isInteger(val)) throw new Error('BigUInt64: val='+val+' typeof='+typeof(val));						
						val = BigInt(val)
					}
					if(val<0n || val>18446744073709551615n) throw new Error('BigUInt64: must be in range [0n, 18446744073709551615n]. Given: '+val);						
					this.setBigUInt64(this.pos, val, false)
					this.pos  += 8;
				}
				bytesBigUInt64BE(val) {return 8;}
	
			//BigUInt64LE
				readNextBigUInt64LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('BigUInt64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					const res  = this.getBigUInt64(this.pos, true);
					this.pos  += 8;
					return res;
				}
				writeNextBigUInt64LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 8 > this.buf.length) throw new Error('BigUInt64:this.pos + 8 = '+(this.pos+8)+'> this.buf.length='+this.buf.length);
					if(typeof(val)!=='bigint'){ if(!Number.isInteger(val)) throw new Error('BigUInt64: val='+val+' typeof='+typeof(val));						
						val = BigInt(val)
					}
					if(val<0n || val>18446744073709551615n) throw new Error('BigUInt64: must be in range [0n, 18446744073709551615n]. Given: '+val);						
					this.setBigUInt64(this.pos, val, true)
					this.pos  += 8;
				}
				bytesBigUInt64LE(val) {return 8;}
	
			//UIntBE
				readNextUIntBE(bytes){ 
					if(!Number.isInteger(bytes) || bytes>6 || bytes<1) throw new Error('UInt: bytes must be Int in range [1,6]. Given: bytes');
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + bytes > this.buf.length) throw new Error('UInt:this.pos + bytes = '+(this.pos+bytes)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readUIntBE(this.pos, bytes);
					this.pos  += bytes;
					return res;
				}
				writeNextUIntBE(val, bytes){ 
					if(!Number.isInteger(bytes) || bytes>6 || bytes<1) throw new Error('UInt: bytes must be Int in range [1,6]. Given: bytes');
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + bytes > this.buf.length) throw new Error('UInt:this.pos + bytes = '+(this.pos+bytes)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt: val='+val+' typeof='+typeof(val));
					if(val<0 || val>maxUIntByBytes[bytes]) throw new Error('UInt: val must be in range ['+0+','+maxUIntByBytes[bytes]+']. Given: '+val);						
					this.buf.writeUIntBE(val, this.pos, bytes)
					this.pos  += bytes;
				}
				bytesUIntBE(val, bytes) {return bytes;}
	
			//UIntLE
				readNextUIntLE(bytes){ 
					if(!Number.isInteger(bytes) || bytes>6 || bytes<1) throw new Error('UInt: bytes must be Int in range [1,6]. Given: bytes');
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + bytes > this.buf.length) throw new Error('UInt:this.pos + bytes = '+(this.pos+bytes)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readUIntLE(this.pos, bytes);
					this.pos  += bytes;
					return res;
				}
				writeNextUIntLE(val, bytes){ 
					if(!Number.isInteger(bytes) || bytes>6 || bytes<1) throw new Error('UInt: bytes must be Int in range [1,6]. Given: bytes');
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + bytes > this.buf.length) throw new Error('UInt:this.pos + bytes = '+(this.pos+bytes)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt: val='+val+' typeof='+typeof(val));
					if(val<0 || val>maxUIntByBytes[bytes]) throw new Error('UInt: val must be in range ['+0+','+maxUIntByBytes[bytes]+']. Given: '+val);						
					this.buf.writeUIntLE(val, this.pos, bytes)
					this.pos  += bytes;
				}
				bytesUIntLE(val, bytes) {return bytes;}
	
			//UInt24BE
				readNextUInt24BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 3 > this.buf.length) throw new Error('UInt24:this.pos + 3 = '+(this.pos+3)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readUIntBE(this.pos, 3);
					this.pos  += 3;
					return res;
				}
				writeNextUInt24BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 3 > this.buf.length) throw new Error('UInt24:this.pos + 3 = '+(this.pos+3)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt24: val='+val+' typeof='+typeof(val));
					if(val<0 || val>16777215) throw new Error('UInt24: must be in range [0, 16777215]. Given: '+val);						
					this.buf.writeUIntBE(val, this.pos, 3)
					this.pos  += 3;
				}
				bytesUInt24BE(val) {return 3;}
	
			//UInt24LE
				readNextUInt24LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 3 > this.buf.length) throw new Error('UInt24:this.pos + 3 = '+(this.pos+3)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readUIntLE(this.pos, 3);
					this.pos  += 3;
					return res;
				}
				writeNextUInt24LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 3 > this.buf.length) throw new Error('UInt24:this.pos + 3 = '+(this.pos+3)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt24: val='+val+' typeof='+typeof(val));
					if(val<0 || val>16777215) throw new Error('UInt24: must be in range [0, 16777215]. Given: '+val);						
					this.buf.writeUIntLE(val, this.pos, 3)
					this.pos  += 3;
				}
				bytesUInt24LE(val) {return 3;}
	
			//UInt40BE
				readNextUInt40BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 5 > this.buf.length) throw new Error('UInt40:this.pos + 5 = '+(this.pos+5)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readUIntBE(this.pos, 5);
					this.pos  += 5;
					return res;
				}
				writeNextUInt40BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 5 > this.buf.length) throw new Error('UInt40:this.pos + 5 = '+(this.pos+5)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt40: val='+val+' typeof='+typeof(val));
					if(val<0 || val>1099511627775) throw new Error('UInt40: must be in range [0, 1099511627775]. Given: '+val);						
					this.buf.writeUIntBE(val, this.pos, 5)
					this.pos  += 5;
				}
				bytesUInt40BE(val) {return 5;}
	
			//UInt40LE
				readNextUInt40LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 5 > this.buf.length) throw new Error('UInt40:this.pos + 5 = '+(this.pos+5)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readUIntLE(this.pos, 5);
					this.pos  += 5;
					return res;
				}
				writeNextUInt40LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 5 > this.buf.length) throw new Error('UInt40:this.pos + 5 = '+(this.pos+5)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt40: val='+val+' typeof='+typeof(val));
					if(val<0 || val>1099511627775) throw new Error('UInt40: must be in range [0, 1099511627775]. Given: '+val);						
					this.buf.writeUIntLE(val, this.pos, 5)
					this.pos  += 5;
				}
				bytesUInt40LE(val) {return 5;}
	
			//UInt48BE
				readNextUInt48BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 6 > this.buf.length) throw new Error('UInt48:this.pos + 6 = '+(this.pos+6)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readUIntBE(this.pos, 6);
					this.pos  += 6;
					return res;
				}
				writeNextUInt48BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 6 > this.buf.length) throw new Error('UInt48:this.pos + 6 = '+(this.pos+6)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt48: val='+val+' typeof='+typeof(val));
					if(val<0 || val>281474976710655) throw new Error('UInt48: must be in range [0, 281474976710655]. Given: '+val);						
					this.buf.writeUIntBE(val, this.pos, 6)
					this.pos  += 6;
				}
				bytesUInt48BE(val) {return 6;}
	
			//UInt48LE
				readNextUInt48LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 6 > this.buf.length) throw new Error('UInt48:this.pos + 6 = '+(this.pos+6)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readUIntLE(this.pos, 6);
					this.pos  += 6;
					return res;
				}
				writeNextUInt48LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 6 > this.buf.length) throw new Error('UInt48:this.pos + 6 = '+(this.pos+6)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('UInt48: val='+val+' typeof='+typeof(val));
					if(val<0 || val>281474976710655) throw new Error('UInt48: must be in range [0, 281474976710655]. Given: '+val);						
					this.buf.writeUIntLE(val, this.pos, 6)
					this.pos  += 6;
				}
				bytesUInt48LE(val) {return 6;}
	
			//IntBE
				readNextIntBE(bytes){ 
					if(!Number.isInteger(bytes) || bytes>6 || bytes<1) throw new Error('Int: bytes must be Int in range [1,6]. Given: bytes');
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + bytes > this.buf.length) throw new Error('Int:this.pos + bytes = '+(this.pos+bytes)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readIntBE(this.pos, bytes);
					this.pos  += bytes;
					return res;
				}
				writeNextIntBE(val, bytes){ 
					if(!Number.isInteger(bytes) || bytes>6 || bytes<1) throw new Error('Int: bytes must be Int in range [1,6]. Given: bytes');
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + bytes > this.buf.length) throw new Error('Int:this.pos + bytes = '+(this.pos+bytes)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int: val='+val+' typeof='+typeof(val));
					if(val<minIntByBytes[bytes] || val>maxIntByBytes[bytes]) throw new Error('Int: val must be in range ['+minIntByBytes[bytes]+','+maxIntByBytes[bytes]+']. Given: '+val);						
					this.buf.writeIntBE(val, this.pos, bytes)
					this.pos  += bytes;
				}
				bytesIntBE(val, bytes) {return bytes;}
	
			//IntLE
				readNextIntLE(bytes){ 
					if(!Number.isInteger(bytes) || bytes>6 || bytes<1) throw new Error('Int: bytes must be Int in range [1,6]. Given: bytes');
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + bytes > this.buf.length) throw new Error('Int:this.pos + bytes = '+(this.pos+bytes)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readIntLE(this.pos, bytes);
					this.pos  += bytes;
					return res;
				}
				writeNextIntLE(val, bytes){ 
					if(!Number.isInteger(bytes) || bytes>6 || bytes<1) throw new Error('Int: bytes must be Int in range [1,6]. Given: bytes');
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + bytes > this.buf.length) throw new Error('Int:this.pos + bytes = '+(this.pos+bytes)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int: val='+val+' typeof='+typeof(val));
					if(val<minIntByBytes[bytes] || val>maxIntByBytes[bytes]) throw new Error('Int: val must be in range ['+minIntByBytes[bytes]+','+maxIntByBytes[bytes]+']. Given: '+val);						
					this.buf.writeIntLE(val, this.pos, bytes)
					this.pos  += bytes;
				}
				bytesIntLE(val, bytes) {return bytes;}
	
			//Int24BE
				readNextInt24BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 3 > this.buf.length) throw new Error('Int24:this.pos + 3 = '+(this.pos+3)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readIntBE(this.pos, 3);
					this.pos  += 3;
					return res;
				}
				writeNextInt24BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 3 > this.buf.length) throw new Error('Int24:this.pos + 3 = '+(this.pos+3)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int24: val='+val+' typeof='+typeof(val));
					if(val<-8388608 || val>8388607) throw new Error('Int24: must be in range [-8388608, 8388607]. Given: '+val);						
					this.buf.writeIntBE(val, this.pos, 3)
					this.pos  += 3;
				}
				bytesInt24BE(val) {return 3;}
	
			//Int24LE
				readNextInt24LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 3 > this.buf.length) throw new Error('Int24:this.pos + 3 = '+(this.pos+3)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readIntLE(this.pos, 3);
					this.pos  += 3;
					return res;
				}
				writeNextInt24LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 3 > this.buf.length) throw new Error('Int24:this.pos + 3 = '+(this.pos+3)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int24: val='+val+' typeof='+typeof(val));
					if(val<-8388608 || val>8388607) throw new Error('Int24: must be in range [-8388608, 8388607]. Given: '+val);						
					this.buf.writeIntLE(val, this.pos, 3)
					this.pos  += 3;
				}
				bytesInt24LE(val) {return 3;}
	
			//Int40BE
				readNextInt40BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 5 > this.buf.length) throw new Error('Int40:this.pos + 5 = '+(this.pos+5)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readIntBE(this.pos, 5);
					this.pos  += 5;
					return res;
				}
				writeNextInt40BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 5 > this.buf.length) throw new Error('Int40:this.pos + 5 = '+(this.pos+5)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int40: val='+val+' typeof='+typeof(val));
					if(val<-549755813888 || val>549755813887) throw new Error('Int40: must be in range [-549755813888, 549755813887]. Given: '+val);						
					this.buf.writeIntBE(val, this.pos, 5)
					this.pos  += 5;
				}
				bytesInt40BE(val) {return 5;}
	
			//Int40LE
				readNextInt40LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 5 > this.buf.length) throw new Error('Int40:this.pos + 5 = '+(this.pos+5)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readIntLE(this.pos, 5);
					this.pos  += 5;
					return res;
				}
				writeNextInt40LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 5 > this.buf.length) throw new Error('Int40:this.pos + 5 = '+(this.pos+5)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int40: val='+val+' typeof='+typeof(val));
					if(val<-549755813888 || val>549755813887) throw new Error('Int40: must be in range [-549755813888, 549755813887]. Given: '+val);						
					this.buf.writeIntLE(val, this.pos, 5)
					this.pos  += 5;
				}
				bytesInt40LE(val) {return 5;}
	
			//Int48BE
				readNextInt48BE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 6 > this.buf.length) throw new Error('Int48:this.pos + 6 = '+(this.pos+6)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readIntBE(this.pos, 6);
					this.pos  += 6;
					return res;
				}
				writeNextInt48BE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 6 > this.buf.length) throw new Error('Int48:this.pos + 6 = '+(this.pos+6)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int48: val='+val+' typeof='+typeof(val));
					if(val<-140737488355328 || val>140737488355327) throw new Error('Int48: must be in range [-140737488355328, 140737488355327]. Given: '+val);						
					this.buf.writeIntBE(val, this.pos, 6)
					this.pos  += 6;
				}
				bytesInt48BE(val) {return 6;}
	
			//Int48LE
				readNextInt48LE(){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 6 > this.buf.length) throw new Error('Int48:this.pos + 6 = '+(this.pos+6)+'> this.buf.length='+this.buf.length);
					const res  = this.buf.readIntLE(this.pos, 6);
					this.pos  += 6;
					return res;
				}
				writeNextInt48LE(val){ 
					if(this.bitPos!==0) throw new Error('this.bitPos='+this.bitPos);
					if(this.pos + 6 > this.buf.length) throw new Error('Int48:this.pos + 6 = '+(this.pos+6)+'> this.buf.length='+this.buf.length);
					if(!Number.isInteger(val)) throw new Error('Int48: val='+val+' typeof='+typeof(val));
					if(val<-140737488355328 || val>140737488355327) throw new Error('Int48: must be in range [-140737488355328, 140737488355327]. Given: '+val);						
					this.buf.writeIntLE(val, this.pos, 6)
					this.pos  += 6;
				}
				bytesInt48LE(val) {return 6;}

		//microUInt.js
			//MicroUInt
				readNextMicroUInt(bits){ 
					if(!Number.isInteger(bits) || bits<0 || bits>7)  throw new Error("MicroUInt: bits must be in [1,7]. Given:"+bits); 
					if(this.pos>=this.buf.length) throw new Error('MicroUInt: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + bits; 
					if(end>8) throw new Error("MicroUInt: 8<end="+end)
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & ((1 << bits) - 1);
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextMicroUInt(val, bits){ 
					if(!Number.isInteger(bits) || bits<0 || bits>7)  throw new Error("MicroUInt: bits must be in [1,7]. Given:"+bits); 
					if(!Number.isInteger(val) || val<0 || val>((1 << bits) - 1)) throw new Error("MicroUInt: val must be in [0,"+((1 << bits) - 1)+"]. Given:"+val); 
					if(this.pos>=this.buf.length) throw new Error('MicroUInt: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + bits; 
					if(end>8) throw new Error("MicroUInt: 8<end="+end)
					let x     = this._typedUInt8[this.pos];
					x &= ~(((1 << bits) - 1) << (8 - end)); // Clear the relevant bits
					x |= (val & ((1 << bits) - 1)) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesMicroUInt(val, bits){ 
					if(!Number.isInteger(bits) || bits<0 || bits>7)  throw new Error("MicroUInt: bits must be in [1,7]. Given:"+bits);
					const end = this.bitPos + bits; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt1
				readNextUInt1(){  
					if(this.pos>=this.buf.length) throw new Error('UInt1: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 1; 
					if(end>8) throw new Error("UInt1: 8<end="+end)
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 1;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt1(val){  
					if(!Number.isInteger(val) || val<0 || val>1) throw new Error("UInt1: val must be in [0,"+1+"]. Given:"+val); 
					if(this.pos>=this.buf.length) throw new Error('UInt1: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 1; 
					if(end>8) throw new Error("UInt1: 8<end="+end)
					let x     = this._typedUInt8[this.pos];
					x &= ~(1 << (8 - end)); // Clear the relevant bits
					x |= (val & 1) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt1(val){ 
					const end = this.bitPos + 1; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt2
				readNextUInt2(){  
					if(this.pos>=this.buf.length) throw new Error('UInt2: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 2; 
					if(end>8) throw new Error("UInt2: 8<end="+end)
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 3;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt2(val){  
					if(!Number.isInteger(val) || val<0 || val>3) throw new Error("UInt2: val must be in [0,"+3+"]. Given:"+val); 
					if(this.pos>=this.buf.length) throw new Error('UInt2: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 2; 
					if(end>8) throw new Error("UInt2: 8<end="+end)
					let x     = this._typedUInt8[this.pos];
					x &= ~(3 << (8 - end)); // Clear the relevant bits
					x |= (val & 3) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt2(val){ 
					const end = this.bitPos + 2; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt3
				readNextUInt3(){  
					if(this.pos>=this.buf.length) throw new Error('UInt3: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 3; 
					if(end>8) throw new Error("UInt3: 8<end="+end)
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 7;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt3(val){  
					if(!Number.isInteger(val) || val<0 || val>7) throw new Error("UInt3: val must be in [0,"+7+"]. Given:"+val); 
					if(this.pos>=this.buf.length) throw new Error('UInt3: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 3; 
					if(end>8) throw new Error("UInt3: 8<end="+end)
					let x     = this._typedUInt8[this.pos];
					x &= ~(7 << (8 - end)); // Clear the relevant bits
					x |= (val & 7) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt3(val){ 
					const end = this.bitPos + 3; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt4
				readNextUInt4(){  
					if(this.pos>=this.buf.length) throw new Error('UInt4: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 4; 
					if(end>8) throw new Error("UInt4: 8<end="+end)
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 15;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt4(val){  
					if(!Number.isInteger(val) || val<0 || val>15) throw new Error("UInt4: val must be in [0,"+15+"]. Given:"+val); 
					if(this.pos>=this.buf.length) throw new Error('UInt4: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 4; 
					if(end>8) throw new Error("UInt4: 8<end="+end)
					let x     = this._typedUInt8[this.pos];
					x &= ~(15 << (8 - end)); // Clear the relevant bits
					x |= (val & 15) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt4(val){ 
					const end = this.bitPos + 4; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt5
				readNextUInt5(){  
					if(this.pos>=this.buf.length) throw new Error('UInt5: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 5; 
					if(end>8) throw new Error("UInt5: 8<end="+end)
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 31;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt5(val){  
					if(!Number.isInteger(val) || val<0 || val>31) throw new Error("UInt5: val must be in [0,"+31+"]. Given:"+val); 
					if(this.pos>=this.buf.length) throw new Error('UInt5: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 5; 
					if(end>8) throw new Error("UInt5: 8<end="+end)
					let x     = this._typedUInt8[this.pos];
					x &= ~(31 << (8 - end)); // Clear the relevant bits
					x |= (val & 31) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt5(val){ 
					const end = this.bitPos + 5; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt6
				readNextUInt6(){  
					if(this.pos>=this.buf.length) throw new Error('UInt6: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 6; 
					if(end>8) throw new Error("UInt6: 8<end="+end)
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 63;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt6(val){  
					if(!Number.isInteger(val) || val<0 || val>63) throw new Error("UInt6: val must be in [0,"+63+"]. Given:"+val); 
					if(this.pos>=this.buf.length) throw new Error('UInt6: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 6; 
					if(end>8) throw new Error("UInt6: 8<end="+end)
					let x     = this._typedUInt8[this.pos];
					x &= ~(63 << (8 - end)); // Clear the relevant bits
					x |= (val & 63) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt6(val){ 
					const end = this.bitPos + 6; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt7
				readNextUInt7(){  
					if(this.pos>=this.buf.length) throw new Error('UInt7: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 7; 
					if(end>8) throw new Error("UInt7: 8<end="+end)
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 127;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt7(val){  
					if(!Number.isInteger(val) || val<0 || val>127) throw new Error("UInt7: val must be in [0,"+127+"]. Given:"+val); 
					if(this.pos>=this.buf.length) throw new Error('UInt7: this.pos='+this.pos+' >= this.buf.length='+this.buf.length+'')
					const end = this.bitPos + 7; 
					if(end>8) throw new Error("UInt7: 8<end="+end)
					let x     = this._typedUInt8[this.pos];
					x &= ~(127 << (8 - end)); // Clear the relevant bits
					x |= (val & 127) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt7(val){ 
					const end = this.bitPos + 7; 
					return (end===8) ? 1 : 0;
				}
				

		//uIntX.js
			readNextUIntXLE(){ 
				if(this.pos+1>this.buf.length) throw new Error('UIntX: this.pos+1 ='+(this.pos+1)+' >=this.buf.length='+this.buf.length);
				if(this.bitPos!==0) throw new Error('UIntX: this.bitPos='+this.bitPos);
				let i = this.readNextUInt8();
				if(i<MaxUIntXB0){
					return i;
				} else if(i===255){
					return this.readNextBigUInt64LE()
				} else if(i>=250){
					if(i===254){
						return this.readNextUIntLE(6);
					} else {
						const b = i-248;
						return this.readNextUIntLE(b) + MaxUIntXBM[b];
					}
				} else {
					return this.readNextUInt8() + MaxUIntXB0 + ((i-MaxUIntXB0)<<8); //*256
				}
			}
			writeNextUIntXLE(val){
				if(this.pos+1>this.buf.length) throw new Error('UIntX: this.pos+1 ='+(this.pos+1)+' >=this.buf.length='+this.buf.length);
				if(this.bitPos!==0) throw new Error('UIntX: this.bitPos='+this.bitPos);
				if(val<0 || (!Number.isInteger(val) && typeof(val)!=='bigint')) {
					throw new Error('UIntX: val='+val+' typeof='+typeof(val)+'. Expecting not negative Int');
				}
				if(val<MaxUIntXB0){
					this.writeNextUInt8(val);
					return 1;
				} else if(val<MaxUIntXB1){
					const n = val - MaxUIntXB0;
					this.writeNextUInt8(MaxUIntXB0 + (n>>8));
					this.writeNextUInt8(n & 255);
					return 2;
				} else if(val<MaxUIntXB2){
					this.writeNextUInt8(250);
					this.writeNextUIntLE(val-MaxUIntXB1, 2);
					return 3;
				} else if(val<MaxUIntXB3){
					this.writeNextUInt8(251);
					this.writeNextUIntLE(val-MaxUIntXB2, 3);
					return 4;
				} else if(val<MaxUIntXB4){
					this.writeNextUInt8(252);
					this.writeNextUIntLE(val-MaxUIntXB3, 4);
					return 5;
				} else if(val<MaxUIntXB5){
					this.writeNextUInt8(253);
					this.writeNextUIntLE(val-MaxUIntXB4, 5);
					return 6;
				} else if(val<MaxUIntXB6){
					this.writeNextUInt8(254);
					this.writeNextUIntLE(val, 6);
					return 7;
				} else {
					this.writeNextUInt8(255);
					this.writeNextBigUInt64LE(val);
					return 9;
				}
			}
			bytesUIntXLE(val){
				if(this.pos+1>this.buf.length) throw new Error('UIntX: this.pos+1 ='+(this.pos+1)+' >=this.buf.length='+this.buf.length);
				if(this.bitPos!==0) throw new Error('UIntX: this.bitPos='+this.bitPos);
				if(val<0 || (!Number.isInteger(val) && typeof(val)!=='bigint')) {
					throw new Error('UIntX: val='+val+' typeof='+typeof(val)+'. Expecting not negative Int');
				}
				if(val<MaxUIntXB0){
					return 1;
				} else if(val<MaxUIntXB1){
					return 2;
				} else if(val<MaxUIntXB2){
					return 3;
				} else if(val<MaxUIntXB3){
					return 4;
				} else if(val<MaxUIntXB4){
					return 5;
				} else if(val<MaxUIntXB5){
					return 6;
				} else if(val<MaxUIntXB6){
					return 7;
				} else {
					return 9;
				}
			}
			readNextUIntXBE(){ 
				if(this.pos+1>this.buf.length) throw new Error('UIntX: this.pos+1 ='+(this.pos+1)+' >=this.buf.length='+this.buf.length);
				if(this.bitPos!==0) throw new Error('UIntX: this.bitPos='+this.bitPos);
				let i = this.readNextUInt8();
				if(i<MaxUIntXB0){
					return i;
				} else if(i===255){
					return this.readNextBigUInt64BE()
				} else if(i>=250){
					if(i===254){
						return this.readNextUIntBE(6);
					} else {
						const b = i-248;
						return this.readNextUIntBE(b) + MaxUIntXBM[b];
					}
				} else {
					return this.readNextUInt8() + MaxUIntXB0 + ((i-MaxUIntXB0)<<8); //*256
				}
			}
			writeNextUIntXBE(val){
				if(this.pos+1>this.buf.length) throw new Error('UIntX: this.pos+1 ='+(this.pos+1)+' >=this.buf.length='+this.buf.length);
				if(this.bitPos!==0) throw new Error('UIntX: this.bitPos='+this.bitPos);
				if(val<0 || (!Number.isInteger(val) && typeof(val)!=='bigint')) {
					throw new Error('UIntX: val='+val+' typeof='+typeof(val)+'. Expecting not negative Int');
				}
				if(val<MaxUIntXB0){
					this.writeNextUInt8(val);
					return 1;
				} else if(val<MaxUIntXB1){
					const n = val - MaxUIntXB0;
					this.writeNextUInt8(MaxUIntXB0 + (n>>8));
					this.writeNextUInt8(n & 255);
					return 2;
				} else if(val<MaxUIntXB2){
					this.writeNextUInt8(250);
					this.writeNextUIntBE(val-MaxUIntXB1, 2);
					return 3;
				} else if(val<MaxUIntXB3){
					this.writeNextUInt8(251);
					this.writeNextUIntBE(val-MaxUIntXB2, 3);
					return 4;
				} else if(val<MaxUIntXB4){
					this.writeNextUInt8(252);
					this.writeNextUIntBE(val-MaxUIntXB3, 4);
					return 5;
				} else if(val<MaxUIntXB5){
					this.writeNextUInt8(253);
					this.writeNextUIntBE(val-MaxUIntXB4, 5);
					return 6;
				} else if(val<MaxUIntXB6){
					this.writeNextUInt8(254);
					this.writeNextUIntBE(val, 6);
					return 7;
				} else {
					this.writeNextUInt8(255);
					this.writeNextBigUInt64BE(val);
					return 9;
				}
			}
			bytesUIntXBE(val){
				if(this.pos+1>this.buf.length) throw new Error('UIntX: this.pos+1 ='+(this.pos+1)+' >=this.buf.length='+this.buf.length);
				if(this.bitPos!==0) throw new Error('UIntX: this.bitPos='+this.bitPos);
				if(val<0 || (!Number.isInteger(val) && typeof(val)!=='bigint')) {
					throw new Error('UIntX: val='+val+' typeof='+typeof(val)+'. Expecting not negative Int');
				}
				if(val<MaxUIntXB0){
					return 1;
				} else if(val<MaxUIntXB1){
					return 2;
				} else if(val<MaxUIntXB2){
					return 3;
				} else if(val<MaxUIntXB3){
					return 4;
				} else if(val<MaxUIntXB4){
					return 5;
				} else if(val<MaxUIntXB5){
					return 6;
				} else if(val<MaxUIntXB6){
					return 7;
				} else {
					return 9;
				}
			}

		//uDoubleH.js
			writeNextUDoubleH(val){
				if(this.bitPos!==0) throw new Error('UDoubleH: this.bitPos='+this.bitPos);
				if(this.pos+2>this.buf.length) throw new Error('UDoubleH: this.pos+2='+(this.pos+2)+'>this.buf.length='+this.buf.length);
					
					if(typeof(val)!=='number') throw new Error('UDoubleH: val='+val+' typeof(val)='+typeof(val));
				if(isNaN(val)) {//to 2 dots: '..'
					this.writeNextUInt1(1);//минус		
					this.writeNextUInt3(0);//длина 0+2 = 2
					this.writeNextUInt4(10);//.
					this.writeNextUInt4(10);//.
					this.bitPos = 0;
					this.pos++;
					//this.writeNextUInt4(1);
					return;
				};
				if(val===-0) val = +0; 
				if(val<0) throw new Error('UFloat must be >=0 Given:'+val);
				if(!isFinite(val)) {//to 3 dots: '...'
					this.writeNextUInt1(1);//минус		
					this.writeNextUInt3(1);//длина 1+2 = 3
					this.writeNextUInt4(10);//.
					this.writeNextUInt4(10);//.
					this.writeNextUInt4(10);//.
					return;
				}		
					
				let str = val+'';
				if(str==='.0'){
					str ='0.';
				} else if(str.length===1){
					str += '.';
				} else if(str.startsWith('0.') && str.length!==2){
					str = str.substring(1)
				}
					
				let   cLen = 0
				const sLen = str.length;
				for(let i=0; i<sLen; i++){
					const cur = str[i];
					if(cur==='0'){
						if(str[i+1]!=='0'){
							ud_cArr[cLen++] = 0; 
						} else if(str[i+2]!=='0'){
							ud_cArr[cLen++] = 13; 
							i++;
						} else {
							ud_cArr[cLen++] = 15; 
							i+= 2;
						}
					} else if(cur==='e'){
						if(str[i+1]==='-'){
							ud_cArr[cLen++] = 11;
						} else if(str[i+1]==='+'){
							ud_cArr[cLen++] = 12;
						} else throw new Error('Bad symbol after e "'+str[i+1]+'" in "'+str+'". Expecting - or +');
						i++;
					} else if(cur==='.'){
						if(str[i+1]!=='0'){
							ud_cArr[cLen++] = 10; 
						} else {
							ud_cArr[cLen++] = 14; 
							i++;
						}
					} else {
						ud_cArr[cLen++] = ud_get(cur);
					}
				}

				if(cLen < 2 || cLen > 9){
					return this.writeNextDoubleBE(val);
				}
				this.writeNextUInt1(1);//минус		
				this.writeNextUInt3(cLen-2);
				for(let i=0; i<cLen; i++){
					this.writeNextUInt4(ud_cArr[i]);
				}
				if(this.bitPos!==0){ //this.writeNextUInt4(0)
					this.bitPos = 0;
					this.pos++;
				}
			}
			bytesUDoubleH(val){
					if(typeof(val)!=='number') throw new Error('UDoubleH: val='+val+' typeof(val)='+typeof(val));
				if(isNaN(val) || !isFinite(val)) {//to 2 dots: '..'
					return 2;
				};
				if(val===-0) val = +0; 
				if(val<0) throw new Error('UFloat must be >=0 Given:'+val);
				
				let str = val+'';
				if(str==='.0'){
					str ='0.';
				} else if(str.length===1){
					str += '.';
				} else if(str.startsWith('0.') && str.length!==2){
					str = str.substring(1)
				}
					
				let   cLen = 0
				const sLen = str.length;
				for(let i=0; i<sLen; i++){
					const cur = str[i];
					if(cur==='0'){
						if(str[i+1]!=='0'){
							cLen++ 
						} else if(str[i+2]!=='0'){
							cLen++
							i++;
						} else {
							cLen++
							i+= 2;
						}
					} else if(cur==='e'){
						if(str[i+1]==='-'){
							cLen++
						} else if(str[i+1]==='+'){
							cLen++
						} else throw new Error('Bad symbol after e "'+str[i+1]+'" in "'+str+'". Expecting - or +');
						i++;
					} else if(cur==='.'){
						if(str[i+1]!=='0'){
							cLen++
						} else {
							cLen++
							i++;
						}
					} else {
						cLen++
					}
				}

				if(cLen < 2 || cLen > 9){
					return 8;
				}
				return Math.ceil((1 + cLen)/2); 
			}			
			readNextUDoubleH(){
				if(this.bitPos!==0) throw new Error('UDoubleH: this.bitPos='+this.bitPos);
				if(this.pos+2>this.buf.length) throw new Error('UDoubleH: this.pos+2='+(this.pos+2)+'>this.buf.length='+this.buf.length);
					
				const sign  = this.readNextUInt1();
				if(sign===0){
					this.bitPos = 0;
					return this.readNextDoubleBE();
				}
				const len = 2 + this.readNextUInt3();
				let str = '';
				for(let i=0;i<len;i++){
					str+= ud_hexToChar[this.readNextUInt4()];			
				}
				if(this.bitPos!==0){
					this.bitPos=0;
					this.pos++
				}
				if(str==='..'){
					return NaN;
				} else if(str==='...'){
					return Infinity;
				} else {
					return parseFloat(str);							
				}
			}
	
};

const proto = SafeCoder.prototype;
['readNext', 'writeNext', 'bytes'].forEach(oper=>{
	['LE', 'BE'].forEach(endian=>{
		proto[oper+'Float'+endian]  = proto[oper+'Float32'+endian];
		proto[oper+'Double'+endian] = proto[oper+'Float64'+endian];		
	})	
})




module.exports = SafeCoder;