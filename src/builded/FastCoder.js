/*
			!!!Warning!!!
			This is autogenerated code! 
*/
		
const assert        = require('node:assert');
const AbstractCoder = require('../AbstractCoder.js');


//basic.js
	const maxUIntByBytes = [null, 255, 65535, 16777215, 4294967295, 1099511627775, 281474976710655]
	const maxIntByBytes  = [null, 127, 32767, 8388607, 2147483647, 549755813887, 140737488355327]
	const minIntByBytes  = [null, -129, -32769, -8388609, -2147483649, -549755813889, -140737488355329]

//uIntX.js
	const MaxUIntXB0 = 240;
	const MaxUIntXB1 = MaxUIntXB0 + 256*9;
	const MaxUIntXB2 = MaxUIntXB1 + Math.pow(2, 2*8);
	const MaxUIntXB3 = MaxUIntXB2 + Math.pow(2, 3*8);
	const MaxUIntXB4 = MaxUIntXB3 + Math.pow(2, 4*8);
	const MaxUIntXB5 = MaxUIntXB4 + Math.pow(2, 5*8);
	const MaxUIntXB6 = 0          + Math.pow(2, 6*8); //чтобы не было переполнения
	const MaxUIntXBM = [0, MaxUIntXB0, MaxUIntXB1, MaxUIntXB2, MaxUIntXB3, MaxUIntXB4, MaxUIntXB5, MaxUIntXB6];

//uDoubleH.js
	const ud_hexToChar = [
		'0',   //0
		'1',   //1
		'2',   //2
		'3',   //3
		'4',   //4
		'5',   //5
		'6',   //6
		'7',   //7
		'8',   //8
		'9',   //9
		'.',   //10
		'e-',  //11
		'e+',  //12
		'00',  //13
		'.0',  //14
		'000', //15
	]
	const ud_cArr = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; //speedUp
	const ud_map = new Map([ //['0', 0], //speedUp
		['1', 1], ['2', 2], ['3', 3],
		['4', 4], ['5', 5], ['6', 6], 
		['7', 7], ['8', 8], ['9', 9]
	]); 
	ud_get = ud_map.get.bind(ud_map); //speedUp

class FastCoder extends AbstractCoder {
	
		//basic.js
	
			//Int8
				readNextInt8(){ 
					return this._typedInt8[this.pos++];
				}
				writeNextInt8(val){   
					this._typedInt8[this.pos++] = val;
				}
				bytesInt8() {return 1;}
	
			//UInt8
				readNextUInt8(){ 
					return this._typedUInt8[this.pos++];
				}
				writeNextUInt8(val){   
					this._typedUInt8[this.pos++] = val;
				}
				bytesUInt8() {return 1;}
	
			//Int16BE
				readNextInt16BE(){ 
					const res  = this.getInt16(this.pos, false);
					this.pos  += 2;
					return res;
				}
				writeNextInt16BE(val){ 						
					this.setInt16(this.pos, val, false)
					this.pos  += 2;
				}
				bytesInt16BE(val) {return 2;}
	
			//Int16LE
				readNextInt16LE(){ 
					const res  = this.getInt16(this.pos, true);
					this.pos  += 2;
					return res;
				}
				writeNextInt16LE(val){ 						
					this.setInt16(this.pos, val, true)
					this.pos  += 2;
				}
				bytesInt16LE(val) {return 2;}
	
			//UInt16BE
				readNextUInt16BE(){ 
					const res  = this.getUInt16(this.pos, false);
					this.pos  += 2;
					return res;
				}
				writeNextUInt16BE(val){ 						
					this.setUInt16(this.pos, val, false)
					this.pos  += 2;
				}
				bytesUInt16BE(val) {return 2;}
	
			//UInt16LE
				readNextUInt16LE(){ 
					const res  = this.getUInt16(this.pos, true);
					this.pos  += 2;
					return res;
				}
				writeNextUInt16LE(val){ 						
					this.setUInt16(this.pos, val, true)
					this.pos  += 2;
				}
				bytesUInt16LE(val) {return 2;}
	
			//Int32BE
				readNextInt32BE(){ 
					const res  = this.getInt32(this.pos, false);
					this.pos  += 4;
					return res;
				}
				writeNextInt32BE(val){ 						
					this.setInt32(this.pos, val, false)
					this.pos  += 4;
				}
				bytesInt32BE(val) {return 4;}
	
			//Int32LE
				readNextInt32LE(){ 
					const res  = this.getInt32(this.pos, true);
					this.pos  += 4;
					return res;
				}
				writeNextInt32LE(val){ 						
					this.setInt32(this.pos, val, true)
					this.pos  += 4;
				}
				bytesInt32LE(val) {return 4;}
	
			//UInt32BE
				readNextUInt32BE(){ 
					const res  = this.getUInt32(this.pos, false);
					this.pos  += 4;
					return res;
				}
				writeNextUInt32BE(val){ 						
					this.setUInt32(this.pos, val, false)
					this.pos  += 4;
				}
				bytesUInt32BE(val) {return 4;}
	
			//UInt32LE
				readNextUInt32LE(){ 
					const res  = this.getUInt32(this.pos, true);
					this.pos  += 4;
					return res;
				}
				writeNextUInt32LE(val){ 						
					this.setUInt32(this.pos, val, true)
					this.pos  += 4;
				}
				bytesUInt32LE(val) {return 4;}
	
			//Float32BE
				readNextFloat32BE(){ 
					const res  = this.getFloat32(this.pos, false);
					this.pos  += 4;
					return res;
				}
				writeNextFloat32BE(val){ 						
					this.setFloat32(this.pos, val, false)
					this.pos  += 4;
				}
				bytesFloat32BE(val) {return 4;}
	
			//Float32LE
				readNextFloat32LE(){ 
					const res  = this.getFloat32(this.pos, true);
					this.pos  += 4;
					return res;
				}
				writeNextFloat32LE(val){ 						
					this.setFloat32(this.pos, val, true)
					this.pos  += 4;
				}
				bytesFloat32LE(val) {return 4;}
	
			//Float64BE
				readNextFloat64BE(){ 
					const res  = this.getFloat64(this.pos, false);
					this.pos  += 8;
					return res;
				}
				writeNextFloat64BE(val){ 						
					this.setFloat64(this.pos, val, false)
					this.pos  += 8;
				}
				bytesFloat64BE(val) {return 8;}
	
			//Float64LE
				readNextFloat64LE(){ 
					const res  = this.getFloat64(this.pos, true);
					this.pos  += 8;
					return res;
				}
				writeNextFloat64LE(val){ 						
					this.setFloat64(this.pos, val, true)
					this.pos  += 8;
				}
				bytesFloat64LE(val) {return 8;}
	
			//BigInt64BE
				readNextBigInt64BE(){ 
					const res  = this.getBigInt64(this.pos, false);
					this.pos  += 8;
					return res;
				}
				writeNextBigInt64BE(val){ 
					if(typeof(val)!=='bigint'){ 						
						val = BigInt(val)
					}						
					this.setBigInt64(this.pos, val, false)
					this.pos  += 8;
				}
				bytesBigInt64BE(val) {return 8;}
	
			//BigInt64LE
				readNextBigInt64LE(){ 
					const res  = this.getBigInt64(this.pos, true);
					this.pos  += 8;
					return res;
				}
				writeNextBigInt64LE(val){ 
					if(typeof(val)!=='bigint'){ 						
						val = BigInt(val)
					}						
					this.setBigInt64(this.pos, val, true)
					this.pos  += 8;
				}
				bytesBigInt64LE(val) {return 8;}
	
			//BigUInt64BE
				readNextBigUInt64BE(){ 
					const res  = this.getBigUInt64(this.pos, false);
					this.pos  += 8;
					return res;
				}
				writeNextBigUInt64BE(val){ 
					if(typeof(val)!=='bigint'){ 						
						val = BigInt(val)
					}						
					this.setBigUInt64(this.pos, val, false)
					this.pos  += 8;
				}
				bytesBigUInt64BE(val) {return 8;}
	
			//BigUInt64LE
				readNextBigUInt64LE(){ 
					const res  = this.getBigUInt64(this.pos, true);
					this.pos  += 8;
					return res;
				}
				writeNextBigUInt64LE(val){ 
					if(typeof(val)!=='bigint'){ 						
						val = BigInt(val)
					}						
					this.setBigUInt64(this.pos, val, true)
					this.pos  += 8;
				}
				bytesBigUInt64LE(val) {return 8;}
	
			//UIntBE
				readNextUIntBE(bytes){ 
					const res  = this.buf.readUIntBE(this.pos, bytes);
					this.pos  += bytes;
					return res;
				}
				writeNextUIntBE(val, bytes){ 						
					this.buf.writeUIntBE(val, this.pos, bytes)
					this.pos  += bytes;
				}
				bytesUIntBE(val, bytes) {return bytes;}
	
			//UIntLE
				readNextUIntLE(bytes){ 
					const res  = this.buf.readUIntLE(this.pos, bytes);
					this.pos  += bytes;
					return res;
				}
				writeNextUIntLE(val, bytes){ 						
					this.buf.writeUIntLE(val, this.pos, bytes)
					this.pos  += bytes;
				}
				bytesUIntLE(val, bytes) {return bytes;}
	
			//UInt24BE
				readNextUInt24BE(){ 
					const res  = this.buf.readUIntBE(this.pos, 3);
					this.pos  += 3;
					return res;
				}
				writeNextUInt24BE(val){ 						
					this.buf.writeUIntBE(val, this.pos, 3)
					this.pos  += 3;
				}
				bytesUInt24BE(val) {return 3;}
	
			//UInt24LE
				readNextUInt24LE(){ 
					const res  = this.buf.readUIntLE(this.pos, 3);
					this.pos  += 3;
					return res;
				}
				writeNextUInt24LE(val){ 						
					this.buf.writeUIntLE(val, this.pos, 3)
					this.pos  += 3;
				}
				bytesUInt24LE(val) {return 3;}
	
			//UInt40BE
				readNextUInt40BE(){ 
					const res  = this.buf.readUIntBE(this.pos, 5);
					this.pos  += 5;
					return res;
				}
				writeNextUInt40BE(val){ 						
					this.buf.writeUIntBE(val, this.pos, 5)
					this.pos  += 5;
				}
				bytesUInt40BE(val) {return 5;}
	
			//UInt40LE
				readNextUInt40LE(){ 
					const res  = this.buf.readUIntLE(this.pos, 5);
					this.pos  += 5;
					return res;
				}
				writeNextUInt40LE(val){ 						
					this.buf.writeUIntLE(val, this.pos, 5)
					this.pos  += 5;
				}
				bytesUInt40LE(val) {return 5;}
	
			//UInt48BE
				readNextUInt48BE(){ 
					const res  = this.buf.readUIntBE(this.pos, 6);
					this.pos  += 6;
					return res;
				}
				writeNextUInt48BE(val){ 						
					this.buf.writeUIntBE(val, this.pos, 6)
					this.pos  += 6;
				}
				bytesUInt48BE(val) {return 6;}
	
			//UInt48LE
				readNextUInt48LE(){ 
					const res  = this.buf.readUIntLE(this.pos, 6);
					this.pos  += 6;
					return res;
				}
				writeNextUInt48LE(val){ 						
					this.buf.writeUIntLE(val, this.pos, 6)
					this.pos  += 6;
				}
				bytesUInt48LE(val) {return 6;}
	
			//IntBE
				readNextIntBE(bytes){ 
					const res  = this.buf.readIntBE(this.pos, bytes);
					this.pos  += bytes;
					return res;
				}
				writeNextIntBE(val, bytes){ 						
					this.buf.writeIntBE(val, this.pos, bytes)
					this.pos  += bytes;
				}
				bytesIntBE(val, bytes) {return bytes;}
	
			//IntLE
				readNextIntLE(bytes){ 
					const res  = this.buf.readIntLE(this.pos, bytes);
					this.pos  += bytes;
					return res;
				}
				writeNextIntLE(val, bytes){ 						
					this.buf.writeIntLE(val, this.pos, bytes)
					this.pos  += bytes;
				}
				bytesIntLE(val, bytes) {return bytes;}
	
			//Int24BE
				readNextInt24BE(){ 
					const res  = this.buf.readIntBE(this.pos, 3);
					this.pos  += 3;
					return res;
				}
				writeNextInt24BE(val){ 						
					this.buf.writeIntBE(val, this.pos, 3)
					this.pos  += 3;
				}
				bytesInt24BE(val) {return 3;}
	
			//Int24LE
				readNextInt24LE(){ 
					const res  = this.buf.readIntLE(this.pos, 3);
					this.pos  += 3;
					return res;
				}
				writeNextInt24LE(val){ 						
					this.buf.writeIntLE(val, this.pos, 3)
					this.pos  += 3;
				}
				bytesInt24LE(val) {return 3;}
	
			//Int40BE
				readNextInt40BE(){ 
					const res  = this.buf.readIntBE(this.pos, 5);
					this.pos  += 5;
					return res;
				}
				writeNextInt40BE(val){ 						
					this.buf.writeIntBE(val, this.pos, 5)
					this.pos  += 5;
				}
				bytesInt40BE(val) {return 5;}
	
			//Int40LE
				readNextInt40LE(){ 
					const res  = this.buf.readIntLE(this.pos, 5);
					this.pos  += 5;
					return res;
				}
				writeNextInt40LE(val){ 						
					this.buf.writeIntLE(val, this.pos, 5)
					this.pos  += 5;
				}
				bytesInt40LE(val) {return 5;}
	
			//Int48BE
				readNextInt48BE(){ 
					const res  = this.buf.readIntBE(this.pos, 6);
					this.pos  += 6;
					return res;
				}
				writeNextInt48BE(val){ 						
					this.buf.writeIntBE(val, this.pos, 6)
					this.pos  += 6;
				}
				bytesInt48BE(val) {return 6;}
	
			//Int48LE
				readNextInt48LE(){ 
					const res  = this.buf.readIntLE(this.pos, 6);
					this.pos  += 6;
					return res;
				}
				writeNextInt48LE(val){ 						
					this.buf.writeIntLE(val, this.pos, 6)
					this.pos  += 6;
				}
				bytesInt48LE(val) {return 6;}

		//microUInt.js
			//MicroUInt
				readNextMicroUInt(bits=1){  
					const end = this.bitPos + bits; 
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & ((1 << bits) - 1);
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextMicroUInt(val, bits=1){   
					const end = this.bitPos + bits; 
					let x     = this._typedUInt8[this.pos];
					x &= ~(((1 << bits) - 1) << (8 - end)); // Clear the relevant bits
					x |= (val & ((1 << bits) - 1)) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesMicroUInt(val, bits=1){ 
					const end = this.bitPos + bits; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt1
				readNextUInt1(){  
					const end = this.bitPos + 1; 
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 1;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt1(val){   
					const end = this.bitPos + 1; 
					let x     = this._typedUInt8[this.pos];
					x &= ~(1 << (8 - end)); // Clear the relevant bits
					x |= (val & 1) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt1(val){ 
					const end = this.bitPos + 1; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt2
				readNextUInt2(){  
					const end = this.bitPos + 2; 
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 3;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt2(val){   
					const end = this.bitPos + 2; 
					let x     = this._typedUInt8[this.pos];
					x &= ~(3 << (8 - end)); // Clear the relevant bits
					x |= (val & 3) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt2(val){ 
					const end = this.bitPos + 2; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt3
				readNextUInt3(){  
					const end = this.bitPos + 3; 
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 7;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt3(val){   
					const end = this.bitPos + 3; 
					let x     = this._typedUInt8[this.pos];
					x &= ~(7 << (8 - end)); // Clear the relevant bits
					x |= (val & 7) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt3(val){ 
					const end = this.bitPos + 3; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt4
				readNextUInt4(){  
					const end = this.bitPos + 4; 
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 15;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt4(val){   
					const end = this.bitPos + 4; 
					let x     = this._typedUInt8[this.pos];
					x &= ~(15 << (8 - end)); // Clear the relevant bits
					x |= (val & 15) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt4(val){ 
					const end = this.bitPos + 4; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt5
				readNextUInt5(){  
					const end = this.bitPos + 5; 
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 31;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt5(val){   
					const end = this.bitPos + 5; 
					let x     = this._typedUInt8[this.pos];
					x &= ~(31 << (8 - end)); // Clear the relevant bits
					x |= (val & 31) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt5(val){ 
					const end = this.bitPos + 5; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt6
				readNextUInt6(){  
					const end = this.bitPos + 6; 
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 63;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt6(val){   
					const end = this.bitPos + 6; 
					let x     = this._typedUInt8[this.pos];
					x &= ~(63 << (8 - end)); // Clear the relevant bits
					x |= (val & 63) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt6(val){ 
					const end = this.bitPos + 6; 
					return (end===8) ? 1 : 0;
				}
				
			//UInt7
				readNextUInt7(){  
					const end = this.bitPos + 7; 
					const res = (this._typedUInt8[this.pos] >> (8 - end)) & 127;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
					return res;
				}
				writeNextUInt7(val){   
					const end = this.bitPos + 7; 
					let x     = this._typedUInt8[this.pos];
					x &= ~(127 << (8 - end)); // Clear the relevant bits
					x |= (val & 127) << (8 - end); // Set the new value
					this._typedUInt8[this.pos] = x;
					if(end===8){
						this.pos++;
						this.bitPos = 0;
					} else {
						this.bitPos = end;
					}
				}
				bytesUInt7(val){ 
					const end = this.bitPos + 7; 
					return (end===8) ? 1 : 0;
				}
				

		//uIntX.js
			readNextUIntXLE(){ 
				let i = this.readNextUInt8();
				if(i<MaxUIntXB0){
					return i;
				} else if(i===255){
					return this.readNextBigUInt64LE()
				} else if(i>=250){
					if(i===254){
						return this.readNextUIntLE(6);
					} else {
						const b = i-248;
						return this.readNextUIntLE(b) + MaxUIntXBM[b];
					}
				} else {
					return this.readNextUInt8() + MaxUIntXB0 + ((i-MaxUIntXB0)<<8); //*256
				}
			}
			writeNextUIntXLE(val){
				
				if(val<MaxUIntXB0){
					this.writeNextUInt8(val);
					return 1;
				} else if(val<MaxUIntXB1){
					const n = val - MaxUIntXB0;
					this.writeNextUInt8(MaxUIntXB0 + (n>>8));
					this.writeNextUInt8(n & 255);
					return 2;
				} else if(val<MaxUIntXB2){
					this.writeNextUInt8(250);
					this.writeNextUIntLE(val-MaxUIntXB1, 2);
					return 3;
				} else if(val<MaxUIntXB3){
					this.writeNextUInt8(251);
					this.writeNextUIntLE(val-MaxUIntXB2, 3);
					return 4;
				} else if(val<MaxUIntXB4){
					this.writeNextUInt8(252);
					this.writeNextUIntLE(val-MaxUIntXB3, 4);
					return 5;
				} else if(val<MaxUIntXB5){
					this.writeNextUInt8(253);
					this.writeNextUIntLE(val-MaxUIntXB4, 5);
					return 6;
				} else if(val<MaxUIntXB6){
					this.writeNextUInt8(254);
					this.writeNextUIntLE(val, 6);
					return 7;
				} else {
					this.writeNextUInt8(255);
					this.writeNextBigUInt64LE(val);
					return 9;
				}
			}
			bytesUIntXLE(val){
				
				if(val<MaxUIntXB0){
					return 1;
				} else if(val<MaxUIntXB1){
					return 2;
				} else if(val<MaxUIntXB2){
					return 3;
				} else if(val<MaxUIntXB3){
					return 4;
				} else if(val<MaxUIntXB4){
					return 5;
				} else if(val<MaxUIntXB5){
					return 6;
				} else if(val<MaxUIntXB6){
					return 7;
				} else {
					return 9;
				}
			}
			readNextUIntXBE(){ 
				let i = this.readNextUInt8();
				if(i<MaxUIntXB0){
					return i;
				} else if(i===255){
					return this.readNextBigUInt64BE()
				} else if(i>=250){
					if(i===254){
						return this.readNextUIntBE(6);
					} else {
						const b = i-248;
						return this.readNextUIntBE(b) + MaxUIntXBM[b];
					}
				} else {
					return this.readNextUInt8() + MaxUIntXB0 + ((i-MaxUIntXB0)<<8); //*256
				}
			}
			writeNextUIntXBE(val){
				
				if(val<MaxUIntXB0){
					this.writeNextUInt8(val);
					return 1;
				} else if(val<MaxUIntXB1){
					const n = val - MaxUIntXB0;
					this.writeNextUInt8(MaxUIntXB0 + (n>>8));
					this.writeNextUInt8(n & 255);
					return 2;
				} else if(val<MaxUIntXB2){
					this.writeNextUInt8(250);
					this.writeNextUIntBE(val-MaxUIntXB1, 2);
					return 3;
				} else if(val<MaxUIntXB3){
					this.writeNextUInt8(251);
					this.writeNextUIntBE(val-MaxUIntXB2, 3);
					return 4;
				} else if(val<MaxUIntXB4){
					this.writeNextUInt8(252);
					this.writeNextUIntBE(val-MaxUIntXB3, 4);
					return 5;
				} else if(val<MaxUIntXB5){
					this.writeNextUInt8(253);
					this.writeNextUIntBE(val-MaxUIntXB4, 5);
					return 6;
				} else if(val<MaxUIntXB6){
					this.writeNextUInt8(254);
					this.writeNextUIntBE(val, 6);
					return 7;
				} else {
					this.writeNextUInt8(255);
					this.writeNextBigUInt64BE(val);
					return 9;
				}
			}
			bytesUIntXBE(val){
				
				if(val<MaxUIntXB0){
					return 1;
				} else if(val<MaxUIntXB1){
					return 2;
				} else if(val<MaxUIntXB2){
					return 3;
				} else if(val<MaxUIntXB3){
					return 4;
				} else if(val<MaxUIntXB4){
					return 5;
				} else if(val<MaxUIntXB5){
					return 6;
				} else if(val<MaxUIntXB6){
					return 7;
				} else {
					return 9;
				}
			}

		//uDoubleH.js
			writeNextUDoubleH(val){
				if(isNaN(val)) {//to 2 dots: '..'
					this.writeNextUInt1(1);//минус		
					this.writeNextUInt3(0);//длина 0+2 = 2
					this.writeNextUInt4(10);//.
					this.writeNextUInt4(10);//.
					this.bitPos = 0;
					this.pos++;
					//this.writeNextUInt4(1);
					return;
				};
				if(val===-0) val = +0; 
				
				if(!isFinite(val)) {//to 3 dots: '...'
					this.writeNextUInt1(1);//минус		
					this.writeNextUInt3(1);//длина 1+2 = 3
					this.writeNextUInt4(10);//.
					this.writeNextUInt4(10);//.
					this.writeNextUInt4(10);//.
					return;
				}		
					
				let str = val+'';
				if(str==='.0'){
					str ='0.';
				} else if(str.length===1){
					str += '.';
				} else if(str.startsWith('0.') && str.length!==2){
					str = str.substring(1)
				}
					
				let   cLen = 0
				const sLen = str.length;
				for(let i=0; i<sLen; i++){
					const cur = str[i];
					if(cur==='0'){
						if(str[i+1]!=='0'){
							ud_cArr[cLen++] = 0; 
						} else if(str[i+2]!=='0'){
							ud_cArr[cLen++] = 13; 
							i++;
						} else {
							ud_cArr[cLen++] = 15; 
							i+= 2;
						}
					} else if(cur==='e'){
						if(str[i+1]==='-'){
							ud_cArr[cLen++] = 11;
						} else if(str[i+1]==='+'){
							ud_cArr[cLen++] = 12;
						} else throw new Error('Bad symbol after e "'+str[i+1]+'" in "'+str+'". Expecting - or +');
						i++;
					} else if(cur==='.'){
						if(str[i+1]!=='0'){
							ud_cArr[cLen++] = 10; 
						} else {
							ud_cArr[cLen++] = 14; 
							i++;
						}
					} else {
						ud_cArr[cLen++] = ud_get(cur);
					}
				}

				if(cLen < 2 || cLen > 9){
					return this.writeNextDoubleBE(val);
				}
				this.writeNextUInt1(1);//минус		
				this.writeNextUInt3(cLen-2);
				for(let i=0; i<cLen; i++){
					this.writeNextUInt4(ud_cArr[i]);
				}
				if(this.bitPos!==0){ //this.writeNextUInt4(0)
					this.bitPos = 0;
					this.pos++;
				}
			}
			bytesUDoubleH(val){
				if(isNaN(val) || !isFinite(val)) {//to 2 dots: '..'
					return 2;
				};
				if(val===-0) val = +0; 
				
				
				let str = val+'';
				if(str==='.0'){
					str ='0.';
				} else if(str.length===1){
					str += '.';
				} else if(str.startsWith('0.') && str.length!==2){
					str = str.substring(1)
				}
					
				let   cLen = 0
				const sLen = str.length;
				for(let i=0; i<sLen; i++){
					const cur = str[i];
					if(cur==='0'){
						if(str[i+1]!=='0'){
							cLen++ 
						} else if(str[i+2]!=='0'){
							cLen++
							i++;
						} else {
							cLen++
							i+= 2;
						}
					} else if(cur==='e'){
						if(str[i+1]==='-'){
							cLen++
						} else if(str[i+1]==='+'){
							cLen++
						} else throw new Error('Bad symbol after e "'+str[i+1]+'" in "'+str+'". Expecting - or +');
						i++;
					} else if(cur==='.'){
						if(str[i+1]!=='0'){
							cLen++
						} else {
							cLen++
							i++;
						}
					} else {
						cLen++
					}
				}

				if(cLen < 2 || cLen > 9){
					return 8;
				}
				return Math.ceil((1 + cLen)/2); 
			}			
			readNextUDoubleH(){
				const sign  = this.readNextUInt1();
				if(sign===0){
					this.bitPos = 0;
					return this.readNextDoubleBE();
				}
				const len = 2 + this.readNextUInt3();
				let str = '';
				for(let i=0;i<len;i++){
					str+= ud_hexToChar[this.readNextUInt4()];			
				}
				if(this.bitPos!==0){
					this.bitPos=0;
					this.pos++
				}
				if(str==='..'){
					return NaN;
				} else if(str==='...'){
					return Infinity;
				} else {
					return parseFloat(str);							
				}
			}
	
};

const proto = FastCoder.prototype;
['readNext', 'writeNext', 'bytes'].forEach(oper=>{
	['LE', 'BE'].forEach(endian=>{
		proto[oper+'Float'+endian]  = proto[oper+'Float32'+endian];
		proto[oper+'Double'+endian] = proto[oper+'Float64'+endian];		
	})	
})




module.exports = FastCoder;